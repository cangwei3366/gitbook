# JVM类加载机制

### 1. Java代码执行流程

java源码->【编译器】(词法分析、语义分析、语法\抽象访问树、语义分析等)-->字节码class文件-->类加载器-->字节码校验器-->(翻译字节码 | JIT 编译器(热点代码缓存))

**类加载器流程**

| **（类加载器子系统）** |        |      |       |
| ------------- | ------ | ---- | ----- |
| 字节码文件         | 加载阶段   | 链接阶段 | 初始化阶段 |
|               | 引导类加载器 | 验证   |       |
|               | 扩展类加载器 | 准备   | 初始化   |
|               | 系统类加载器 | 解析   |       |

**加载阶段**：

* 通过双亲委派机制，通过一个类的全限定名获取定义此类的二进制字节流
* 转为方法区（jdk1.7以前，永久代，1.8元空间）运行时数据结构

**链接阶段**：

* 验证(Verify):目的在于确保class文件的字节流信息符合当前虚拟机要求，
* 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证
* 准备(Perpare)：为类变量分配内存并设置初始值
* 不包含final修饰的static，因为final在编译时候就会分配
* 这里不会为实例变量分配初始化，会随着对象一起分配到堆中
* 解析(Resolve):符号引用转换为直接引用，一般在初始化之后开始解析

**初始化阶段**： 收集类中的所有类变量的赋值动作和静态代码块中的语句

### 2. 破坏双亲委派机制

**第一次破坏**：jdk1.2的java.lang.ClassLoader添加findClass()

用户在自定义类加载逻辑时尽可能重写这个方法。父类加载器加载失败，会自动调用自己的findClass完成加载。

**第二次破坏**：解决各个类加载器协作时基础类型的一致性问题。引入线程上下文类加载器，jdk6提供了java.util.ServiceLoader 以责任链模式加载。

**第三次破坏**：用户追求程序动态性：代码热替换、模块热部署等。osgi框架（一个Bundle就有一个类加载器）

1. java.\*开头的类，委派给父类加载器加载
2. 将委托名单的类，委派给父类加载器加载
3. 将import列表的类，委派给Export这个类的bundle的类加载器加载
4. 否则使用当前bundle的类加载器加载
5. 查找是否类在fragment bundle中
6. 查找是否类Dynamic import列表对应的bundle

例如：jdbc

java中driver类位于启动类加载器路径下lib目录，具体实现是通过各个厂商的驱动jar包

通过设置上下文类加载器，就可以通过系统加载器进行加载

**为什么要自定义类加载器**

隔离加载类（使得各个模块路径类名一样的文件互不影响）

修改类加载方式

扩展加载源

防止源码泄漏
