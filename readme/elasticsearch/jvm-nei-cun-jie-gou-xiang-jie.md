# JVM内存结构详解

Java虚拟机运行时数据区

![](<../../.gitbook/assets/06\_02\_01 (1).png>)

### 1.程序寄存器

java -verbose xxxx.class

使用PC寄存器存储字节码指令地址有什么用呢？

为什么使用PC寄存器记录当前线程的执行地址？

因为CPU需要不断的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。

jvm的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

### 2.虚拟机栈

java指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器。

优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

入栈出栈 不存在gc，会oom

栈大小设置：-Xss

**栈帧**

在这个线程上执行的每个方法都对应一个栈帧

在一条活动线程中，一个时间点上，只会有一个活动的栈帧（栈顶栈帧）

抛出异常后当前栈帧正常弹出（前提是捕获异常）

**栈帧的内部结构**：

* 局部变量表
* 操作数栈（表达式栈）
* 动态连接 （指向运行时常量池的方法引用）
* 方法返回地址（方法正常退出或者异常退出的定义）
* 一些附加信息

**局部变量表**

定义为一个数字数组，主要存储方法参数和方法体内的局部变量。变量类型可以通过unicode码转数值型

所需容量大小是在**编译期**确定下来的，不会被更改。

结构：

使用jclasslib工具

Slot变量槽（局部变量表最基本的存储单元）

32位以内的类型占用一个slot 64位的占用两个slot（long和double占两个槽，其他占一个）

如果当前帧是由**构造方法**或者**实例方法**创建的，那么该对象引用this将会放到index为0的slot处

![](../../.gitbook/assets/06\_02\_03.png)

栈帧中的局部变量表中的槽位是可以重用的

局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

**操作数栈**

数组结构，后进先出。又名表达式栈。

某些字节码指令将值压入操作数栈，其余字节码指令将操作数取出栈，使用后将结果压入栈。

比如执行，复制，求和等操作。

某些方法的返回值也会压入操作数栈。

主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。（大小编译器就确定好了 32bit）

**栈顶缓存技术**

原因：频繁入栈出栈，由于操作数栈在内存中，频繁读写会影响性能

解决办法：将栈顶元素全部缓存在物理cpu的寄存器中，以降低对内存的读写次数，提升执行引擎的执行效率

动态链接、方法返回地址、一些附加信息 （帧数据区）

每一个栈帧内部都包含一个指向**运行时常量池**中该栈帧所属方法的引用。

通过符号引用表示。动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

方法的绑定机制

静态链接：编译时绑定 类方法，final修饰，私有方法，父类方法都属于非虚方法

动态链接：运行时绑定

![](../../.gitbook/assets/06\_02\_04.png)

动态语言

1.8引入lamda表达式 支持invokedynamic ，支持动态语言的特点，js，python算动态

方法重写本质：

为了提高性能，JVM在类的方法区建立一个虚方法表，存放各个方法的实际入口

在类加载的链接阶段创建并开始初始化。如父类和子类，共同继承父类object的方法存放到虚方法表，重写的除外。

方法返回地址

存放调用该方法的pc寄存器的值

方法正常执行完成或者抛出异常非正常退出后，都返回到该方法被调用的位置，区别是异常抛出后不给上层调用者产生返回值

本地方法栈

管理本地方法，线程私有。原理同虚拟机栈。

### 3.堆空间

java7及之前逻辑上分为三部分：新生区+养老区+永久区

java8及之前逻辑上分为三部分：新生区+养老区+元空间

设置堆空间大小：

\-Xms10m -Xmx10m

默认情况下：初始内存大小：物理内存大小/64

​ 最大内存大小：物理内存/4

开发中建议将初始堆内存和最大堆内存设置成相同的值，避免堆扩容和释放的性能消耗

![](../../.gitbook/assets/06\_02\_05.png)

**suriver0和suriver1区使用时只用一个**

![](../../.gitbook/assets/06\_02\_06.png)

&#x20;默认-XX:NEWRATIO=2 表示新生代占1，老年代占2.

在HotSpot中，Eden空间和另外两个Survivor空间比例8：1：1

可以通过设置-XX:SurvivorRatio=8调整空间比例

#### 对象分配过程

注 ：标记-复制之后，谁空谁是to区

![](../../.gitbook/assets/06\_02\_07.png)

#### Minor GC (Young GC)、Major GC（old GC）与Full GC

JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收，大部分时候回收的都是指新生代。

针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）

部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：

新生代收集（Minor GC / Young GC）：只是新生代（Eden \S0,S1）的垃圾收集

老年代收集（Major GC / Old GC） ：只是老年代的垃圾收集

目前，只有CMS GC会有单独收集老年代的行为

混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集

目前，只有G1 GC会有这种行为

整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集

当年轻代空间不足时，就会触发minor GC，这里的年轻代指的是eden区，survivor满不会触发GC（在第二次eden满之后，被动一同GC）；

Minor GC会引发SW，暂停其他用户线程，等待垃圾回收结束。

老年代GC（Major GC / Old GC）触发机制：

出现Major GC，经常会伴随至少一次的Minor GC（但非绝对，在Parallel Scavenge收集器的策略就包括直接进行major GC）

Major GC的卒读一般比Minor GC慢10倍以上

如果Major GC后，内存还不足，就报OOM了

Full GC触发机制：

1.调用System.gc()时，系统建议执行Full GC，但是不必立即执行

2.老年代空间不足

3.方法区空间不足

4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存

5.由Eden区、from区向to区复制时，对象大小大于to区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

GC Roots有哪些

活动线程的相关引用

类的静态变量的引用

JNI引用

#### 内存分配策略（或对象提升规则）

如果对象在Eden出生并经过第一次MinorGC后还存活，并且能被Survivor容纳，将被移动到到Survivor中，并将对象年龄设置为1.

对象在Survivor每经过一次GC,年龄增加一岁，最大15岁，就会被晋升到老年代。

年龄阈值可以通过-XX:MaxTenuringThreshold来设置。

针对不同年龄段的对象分配原则如下所示：

优先分配到Eden

大对象直接分配到老年代

长期存活的对象分配到老年代

动态对象年龄判断

如果Survivior区中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于等于该对象年龄的可以直接进入老年代

空间分配担保:-XX:HandlePromotionFailure

#### 快速分配策略 TLAB

对Eden区进行划分，JVM为每个线程分配一个私有缓存区域。

原因：堆区是线程共享区域，任何线程都能访问到堆区的共享数据

​ 由于实例对象的创建在jvm中非常频繁，因此在并发情况下从堆区划分内存空间是线程不安全的

​ 为避免多个线程操作同一地址，需使用加锁等机制，影响分配速度

好处：可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量。

#### 逃逸分析

使用逃逸分析，编译器可以堆代码做如下优化：

一、栈上分配

二、同步省略（锁消除）

三、分离对象或标量替换

**方法区**

设置方法区大小

\-XXMetaSpaceSize 默认依赖与平台 没有限制

1.8 无永久代、字符串常量池、静态变量保存堆中、其他类型信息、字段、方法保存到本地内存的元空间

**方法区内部结构**

存储已被虚拟机加载的类型信息、常量、静态变量、即使编译器编译后的代码缓存

类型信息：

这个类型的完整有效名称（包名.类名）

这个类型直接父类的完整有效类名

类型修饰符

这个类型直接接口的一个有序列表
