# MySQL 锁机制

### 1. 锁

锁机制用于管理对共享资源的并发访问，提供数据的完整性和一致性。还有操作缓冲池的LRU列表的修改删除操作都依赖于锁。

|      | lock                                  |               latch               |
| ---- | ------------------------------------- | :-------------------------------: |
| 对象   | 事务                                    |                 线程                |
| 保护   | 数据库内容                                 |               内存数据结构              |
| 持续时间 | 整个事务过程                                |                临界资源               |
| 模式   | 行锁、表锁、意向锁                             |              读写锁、互斥量              |
| 死锁   | 通过waits-for- graph、time out等机制检测死锁与处理 | 无检测死锁与处理机制，仅通过应用程序加锁的顺序保证无死锁情况发生。 |
| 存在于  | LockManager                           |              每个数据结构对象             |

### 2.InnoDB存储引擎中的锁

#### 2.1 锁的类型

共享锁（S Lock），类型：行锁。允许事务读一行数据。

排他锁（X Lock），允许事务删除或者更新一行数据。

以下显示共享锁和排他锁的兼容性。

|   | X   | S   |
| - | --- | --- |
| X | 不兼容 | 不兼容 |
| S | 不兼容 | 兼容  |

此外，InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在，称之为意向锁（Intention Lock），属于表级别的锁。

其支持两种意向锁：

意向共享锁 （IX Lock），事务想获取一张表某几行的共享锁 意向排他锁 （IS Lock），事务想获取一张表某几行的排他锁 意向锁与意向锁兼容

#### 2.2 应用

*   一致性非锁定读

    Innodb通过多版本控制的方式来读取当前执行时间数据库中行的数据。

    事务的隔离级别为REPEATABLE READ模式下，innodb的SELECT操作使用一致性非锁定读 类似邻接表，每一个行都有一份快照数据，读取时读取最新快照，因此不会占用和等待表上的锁
*   一致性锁定读

    对SELECT语句支持两种一致性锁定读操作。 select \* from dual FOR UPDATE (X锁) select \* from dual LOCK IN SHARE MODE （S锁）
*   自增长锁

    每个含有自增长值的表都有一个自增长计数器，是一种特殊的表锁机制，在完成自增长值插入的SQL语句后立即释放。

    innodb\_autoinc\_lock\_mode 默认为1 插入类型 插入之前能确定行数，则用互斥量的方式对内存中的计数器累加；如果不能确定，则用传统表锁。

### 3. 行锁算法

*   Record Lock

    单个行记录锁
*   Gap Lock

    间隙锁，锁定一个范围,但不锁定记录。 阻止多个事务插入同一范围，但是会导致Phantom Problem问题的产生。
*   Next-Key Lock

    锁定一个范围，并且锁定锁记录本身。 当查询的索引含有唯一属性和辅助索引时，innodb存储引擎会对唯一属性优化，降级为Record Lock，对辅助索引锁定前后范围，因此，可以对除了唯一属性和前后范围之外的值做操作。

#### Phontom Problem

指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次SQL语句可能返回之前不存在的行。

事务隔离级别为REPEATABLE READ采用的是next-key lock 方式来加锁 READ COMMITTED 级别使用的是RECORD LOCK

如果lock in share mode模式下有多个并发操作，那么next-key-lock有唯一性检查，如果不唯一，则抛出死锁异常

### 4. 锁问题

*   脏读

    脏数据指未提交的数据，即一个事务可以读到另一个事务未提交的数据。 事务隔离级别为READ UNCOMMITTED 才会出现。 replication的slave节点，在此节点查询并不需要特别精确的返回值。 违反了隔离性
*   不可重复读

    在一个事务中，读到了另一个事务已经提交的数据。违反了一致性。 在事务级别为READ COMMITTED级别下产生，但是可以接受。 在REPEATABLE READ 级别下的next-key-lock算法避免不可重复读问题。
*   丢失更新

    一个操作的更新会被另一个事务的更新操作所覆盖。 如银行转钱。 要避免丢失更新的情况，则需要用事务将并发操作变成串行操作。 开启事务，并在查询加排他锁。 for update，则在当前事务下，另一个事务的所有操作都会阻塞等待。

### 5. 阻塞

由于不同锁的兼容问题，有些时候一个事务的锁需要等待另一个事务的锁释放资源，这就是阻塞。 innodb\_lock\_wait\_timeout 动态设定等待时间 innodb\_rollback\_wait\_timeout不可在启动时修改

innodb不会回滚超时引发的错误异常

### 6. 死锁

产生死锁的条件： 互斥条件、请求和保持条件、不可剥夺、循环等待

解决死锁： 超时。设置超时参数 wait-for graph（等待图）死锁检测

wiat-for graph 数据库保存：锁的信息链表、事务等待链表，构成一张图 每个事务请求锁并发生等待的时候都会判断是否有回路，若存在则有死锁，通常innodb存储引擎会选择回滚undo量最小的事务。 机制：深度优先算法，1.2之前是递归，1.2之后是非递归。

发生死锁后 innodb会立刻回滚一个事务

### 7. 锁升级

SQL Server有锁升级 innodb不存在锁升级的问题，因为不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理
